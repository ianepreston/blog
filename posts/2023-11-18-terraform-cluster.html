<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-11-18">
<meta name="description" content="Expanding the limited examples I could find online">

<title>Ian’s blog - Databricks cluster policies in terraform</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Ian’s blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html" rel="" target="">
 <span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/ianepreston" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Databricks cluster policies in terraform</h1>
                  <div>
        <div class="description">
          Expanding the limited examples I could find online
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">databricks</div>
                <div class="quarto-category">terraform</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 18, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#creating-the-policies" id="toc-creating-the-policies" class="nav-link" data-scroll-target="#creating-the-policies">Creating the policies</a>
  <ul class="collapse">
  <li><a href="#runtimes" id="toc-runtimes" class="nav-link" data-scroll-target="#runtimes">Runtimes</a></li>
  <li><a href="#cost-management" id="toc-cost-management" class="nav-link" data-scroll-target="#cost-management">Cost management</a></li>
  <li><a href="#single-of-multi-node" id="toc-single-of-multi-node" class="nav-link" data-scroll-target="#single-of-multi-node">Single of multi node</a></li>
  <li><a href="#auto-termination" id="toc-auto-termination" class="nav-link" data-scroll-target="#auto-termination">Auto termination</a></li>
  <li><a href="#tags" id="toc-tags" class="nav-link" data-scroll-target="#tags">Tags</a></li>
  <li><a href="#actual-cluster-policies" id="toc-actual-cluster-policies" class="nav-link" data-scroll-target="#actual-cluster-policies">Actual cluster policies</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Recently I had to define some <a href="https://learn.microsoft.com/en-ca/azure/databricks/administration-guide/clusters/policies">databricks cluster policies</a> at work using <a href="https://registry.terraform.io/providers/databrickslabs/databricks/latest/docs/resources/cluster_policy">terraform</a>. I didn’t have super sophisticated requirements (at least I didn’t think so), but I still struggled to find sample code online that covered my requirements. This post is a brief write up on what I implemented and why, as well as some notes on potential improvements I might make later as my requirements get more detailed.</p>
</section>
<section id="creating-the-policies" class="level1">
<h1>Creating the policies</h1>
<p>All cluster policies are encoded in JSON, which we create from passing a collection of <code>map</code>s that we <code>merge</code> in terraform into the <code>jsonencode</code> method.</p>
<section id="runtimes" class="level2">
<h2 class="anchored" data-anchor-id="runtimes">Runtimes</h2>
<p>One of the first things we want our cluster policy to enforce is using a recent version of the Databricks Runtime (DBR). Depending on the environment we might further restrict this to LTS releases only. Using a series of <code>data</code> blocks I find all the relevant releases. Note that this will change as new releases come out, so we’ll want to schedule running this to ensure we’re always enforcing the latest runtimes. As an example, this block finds the latest LTS release that supports the ML runtime and has GPU drivers installed:</p>
<pre class="hcl"><code>data "databricks_spark_version" "latest_ml_gpu_lts" {
  latest            = true
  long_term_support = true
  ml                = true
  gpu               = true
}</code></pre>
<p>Another bonus on enforcing runtime policies is it provides an easier way to restrict GPU compute without having to find a list of instance types with GPUs. Since you can’t provision a runtime onto a VM with a GPU unless it includes GPU drivers we can limit access to GPU easily with this.</p>
<p>In terms of which runtimes are enabled I made the assumption that we would want consistency across policies in terms of enabled runtimes. That is, the code does not allow for you to enable GPUs on single node compute policies but disable them on multi node.</p>
<p>You’ll see a bit further down that offering multiple runtime limitations across policies within a workspace would be fairly straightforward but introduce a lot of boilerplate code, at least the way I’ve implemented it. Again, I don’t really see this being a requirement. Specific runtimes are enabled or disabled with the module booleans <code>lts_dbr</code>, <code>ml_dbr</code>, and <code>gpu_dbr</code>. So if <code>lts_dbr</code> is true then only LTS runtimes are enabled, if it’s false users are allowed to choose LTS or the most recent runtime. It’s similar for <code>ml_dbr</code> for ML runtimes and <code>gpu_dbr</code> for ML runtimes with GPU enabled (there is no non-ML GPU enabled runtime)</p>
<p>Setting the actual array of allowed runtimes feels kind of hacky, terraform doesn’t seem to support if else blocks, or other cleaner ways I could think of to do this:</p>
<pre class="hcl"><code>  no_lts_no_ml_no_gpu_arr = (!var.lts_dbr &amp;&amp; !var.ml_dbr &amp;&amp; !var.gpu_dbr) ? [data.databricks_spark_version.latest_lts.id, data.databricks_spark_version.latest.id] : null
  lts_no_ml_no_gpu_arr    = (var.lts_dbr &amp;&amp; !var.ml_dbr &amp;&amp; !var.gpu_dbr) ? [data.databricks_spark_version.latest_lts.id] : null
  lts_ml_no_gpu_arr       = (var.lts_dbr &amp;&amp; var.ml_dbr &amp;&amp; !var.gpu_dbr) ? [data.databricks_spark_version.latest_ml_lts.id, data.databricks_spark_version.latest_lts.id] : null
  lts_ml_gpu_arr          = (var.lts_dbr &amp;&amp; var.ml_dbr &amp;&amp; var.gpu_dbr) ? [data.databricks_spark_version.latest_ml_lts.id, data.databricks_spark_version.latest_lts.id, data.databricks_spark_version.latest_ml_gpu_lts.id] : null
  no_lts_ml_no_gpu_arr    = (!var.lts_dbr &amp;&amp; var.ml_dbr &amp;&amp; !var.gpu_dbr) ? [data.databricks_spark_version.latest_ml_lts.id, data.databricks_spark_version.latest_ml.id, data.databricks_spark_version.latest_lts.id, data.databricks_spark_version.latest.id, ] : null
  no_lts_ml_gpu_arr       = (!var.lts_dbr &amp;&amp; var.ml_dbr &amp;&amp; !var.gpu_dbr) ? [data.databricks_spark_version.latest_ml_lts.id, data.databricks_spark_version.latest_ml.id, data.databricks_spark_version.latest_lts.id, data.databricks_spark_version.latest.id, data.databricks_spark_version.latest_ml_gpu_lts.id, data.databricks_spark_version.latest_ml_gpu.id] : null
  fallback_spark_vers_arr = [data.databricks_spark_version.latest_lts.id]
  runtime_version = {
    "spark_version" : {
      "type" : "allowlist",
      "values" : coalesce(local.no_lts_no_ml_no_gpu_arr, local.lts_no_ml_no_gpu_arr, local.lts_ml_no_gpu_arr, local.no_lts_ml_no_gpu_arr, local.no_lts_ml_gpu_arr, local.fallback_spark_vers_arr),
      "defaultValue" : data.databricks_spark_version.latest_lts.id
    }
  }</code></pre>
<p>basically, whichever of those conditionals is true for the combination of runtime booleans that’s the list of runtimes that will be available to users of that policy. I put just the latest LTS runtime as a fallback just to handle errors, it shouldn’t really come up.</p>
<p>This is honestly more limiting than I’d strictly prefer for the non-LTS releases. As an example, if DBR 14.0 is the latest LTS runtime, and 14.2 is the latest overall runtime, I’d prefer users be able to provision 14.1 as well. To handle that though I think I’d have to do some array sorting and regex inference to find the position of the LTS release in the non-LTS array and return everything up to and including that index, and frankly I didn’t feel like writing that. Maybe I’ll be more motivated in the future.</p>
</section>
<section id="cost-management" class="level2">
<h2 class="anchored" data-anchor-id="cost-management">Cost management</h2>
<p>The next big thing we want to enforce is cost management. One approach would be setting careful limitations on combinations of instance types and number of workers, but databricks also offers a <code>max_dbu</code> parameter which just limits the compute cost. This doesn’t exactly translate to overall cost, as underlying VM costs are not factored in, but they tend to be very closely related to the DBU cost of the instance type, so the simplicity seemed like a worthwhile trade off. Again, I’m assuming that we don’t want to have too many different DBU limits within a given workspace, although I have allowed for interactive and job/DLT compute to have different thresholds. We probably generally want to limit the threshold for exploratory work below what we use to run scheduled jobs. Note that this does introduce a somewhat perverse incentive at the margins to run a larger instance with photon disabled, as enabling photon doubles your DBU cost for any given size of underlying compute.</p>
<p>This is accomplished by passing a line into the compute policy definition that looks something like this:</p>
<pre class="hcl"><code>    { "dbus_per_hour" : { "type" : "range", "maxValue" : var.max_dbu_job } },</code></pre>
</section>
<section id="single-of-multi-node" class="level2">
<h2 class="anchored" data-anchor-id="single-of-multi-node">Single of multi node</h2>
<p>For interactive clusters I’ve created both single node and multi node cluster policies. In theory we shouldn’t really care which a user selects, as long as they’re below their cost threshold, but for less sophisticated users it might reduce complexity to only allow single node clusters.</p>
<pre class="hcl"><code>  single_node = {
    "spark_conf.spark.databricks.cluster.profile" : {
      "type" : "fixed",
      "value" : "singleNode",
      "hidden" : true
    },
    "num_workers" : {
      "type" : "fixed",
      "value" : 0,
      "hidden" : true
    }
  }</code></pre>
<p>This can either be added to or left out of a policy definition to enforce single node</p>
</section>
<section id="auto-termination" class="level2">
<h2 class="anchored" data-anchor-id="auto-termination">Auto termination</h2>
<p>For all interactive policies (it’s not relevant to jobs or DLT) I enforce an auto termination of 10 minutes to minimize cluster idling. We could make that a variable if a need comes up, but I’d personally like to keep it low and consistent for now:</p>
<pre class="hcl"><code>  autotermination = {
    "autotermination_minutes" : {
      "type" : "fixed",
      "value" : 10
      # "hidden" : true
  } }</code></pre>
<p>I took off the <code>hidden</code> flag for now so users can see that it’s been auto set for them. We can remove that later to reduce the complexity of the cluster creation interface.</p>
<p>I have heard some feedback from ML users that it’s not reasonable to expect them to be sitting around ready to pounce on long running tasks when they’re prototyping so I’m going to end up modifying this to a range with a higher maximum value that we can configure for ML workspaces.</p>
</section>
<section id="tags" class="level2">
<h2 class="anchored" data-anchor-id="tags">Tags</h2>
<p>Finally, I added some tags, which right now don’t really do much since I don’t know what additional tags we want to add. A lot gets auto applied that might be sufficient, but I wanted to demonstrate the capability:</p>
<pre class="hcl"><code>  default_tags = {
    "custom_tags.lob" : {
      "type" : "fixed",
      "value" : "${var.lob_name}",
      "hidden" : true
    },
    "custom_tags.TEST" : {
      "type" : "fixed",
      "value" : "testfromterraform"
    }
  }</code></pre>
</section>
<section id="actual-cluster-policies" class="level2">
<h2 class="anchored" data-anchor-id="actual-cluster-policies">Actual cluster policies</h2>
<p>Putting it all together we can define cluster policies like so:</p>
<pre class="hcl"><code>resource "databricks_cluster_policy" "multi-node-personal" {
  count = var.create_multi_node_personal_policy ? 1 : 0
  name  = "Multi Node Personal Compute"
  definition = jsonencode(merge(
    { "dbus_per_hour" : { "type" : "range", "maxValue" : var.max_dbu_interactive } },
    local.runtime_version,
    local.autotermination,
    local.default_tags,
    local.photon
  ))
}</code></pre>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>In this post I demonstrated how to create a set of databricks cluster policies using a terraform module that can be applied to your workspaces. Nothing particularly earth shattering, and I’m not sure whether to be pleased or horrified with that giant block I wrote to produce the acceptable runtime list, but it works and it at least adds some more example code that others can build off.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>